
use std::{io::Cursor, net::UdpSocket};

use libgromnie::on_serialize;
pub struct UptimeClient {
  bind_address: String,
  connect_address: String
}

impl UptimeClient {
  pub fn create(bind_address: String, connect_address: String) -> UptimeClient {
    UptimeClient {
      bind_address, connect_address
    }
  }

  pub fn check(&self) -> Result<usize,std::io::Error> {
    println!("Checking {}", self.connect_address);

    let socket: UdpSocket = UdpSocket::bind(self.bind_address.clone()).expect("Failed to bind");
    let _ = socket.connect(self.connect_address.clone());

    // Send fake login packet
    // TODO: Figure out how to make this from a proper structure rather than
    // a raw vec of bytes
    // let data: [u8; 84] = [
    //       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x93, 0x00,
    //       0xd0, 0x05, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    //       0x04, 0x00, 0x31, 0x38, 0x30, 0x32, 0x00, 0x00, 0x34, 0x00,
    //       0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //       0x3e, 0xb8, 0xa8, 0x58, 0x1c, 0x00, 0x61, 0x63, 0x73, 0x65,
    //       0x72, 0x76, 0x65, 0x72, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x65,
    //       0x72, 0x3a, 0x6a, 0x6a, 0x39, 0x68, 0x32, 0x36, 0x68, 0x63,
    //       0x73, 0x67, 0x67, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //       0x00, 0x00, 0x00, 0x00
    //   ];
    let mut buffer = Cursor::new(Vec::new());

    on_serialize(&mut buffer);

    let serialized_data = buffer.into_inner();

    let _ = socket.send(&serialized_data).unwrap();
    let mut recv_buffer = [0u8; 1024];

    return socket.recv(&mut recv_buffer);
  }
}
