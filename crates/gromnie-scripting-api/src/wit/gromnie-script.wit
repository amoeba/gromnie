package gromnie:scripting@0.1.0;

/// Interface defining what the host (Gromnie) provides to WASM scripts
interface host {
    /// ===== Common Types =====

    /// A game world object (character, NPC, item, etc.)
    record world-object {
        id: u32,
        name: string,
    }

    /// ===== Client Information =====

    /// Current client state snapshot
    record client-state {
        session: client-session,
        scene: scene,
    }

    /// Client session state (protocol state + metadata)
    record client-session {
        state: session-state,
    }

    /// ACE protocol session states
    enum session-state {
        /// Sent LoginRequest, waiting for ConnectRequest
        auth-login-request,
        /// Received ConnectRequest, sent ConnectResponse
        auth-connect-response,
        /// Authenticated and connected
        auth-connected,
        /// Connected to world server
        world-connected,
        /// Termination started
        termination-started,
    }

    /// Scene-based UI state (what the user sees)
    variant scene {
        connecting(connecting-scene),
        character-select(character-select-scene),
        character-create(character-create-scene),
        in-world(in-world-scene),
        error(error-scene),
    }

    /// Connecting scene state
    record connecting-scene {
        connect-progress: connecting-progress,
        patch-progress: patching-progress,
    }

    /// Connecting progress sub-state
    enum connecting-progress {
        initial,
        login-request-sent,
        connect-request-received,
        connect-response-sent,
    }

    /// Patching progress sub-state
    enum patching-progress {
        not-started,
        waiting-for-ddd,
        received-ddd,
        sent-ddd-response,
        complete,
    }

    /// Character select scene state
    record character-select-scene {
        account-name: string,
        characters: list<character-identity>,
        entering-world: option<entering-world-state>,
    }

    /// Character information (matches acprotocol CharacterIdentity)
    record character-identity {
        character-id: u32,
        name: string,
        seconds-greyed-out: u32,
    }

    /// State for entering the world with a character
    record entering-world-state {
        character-id: u32,
        character-name: string,
        account: string,
        login-complete: bool,
    }

    /// Character creation scene state
    record character-create-scene {
        // Stubbed for now
    }

    /// In-world scene state
    record in-world-scene {
        character-id: u32,
        character-name: string,
    }

    /// Error scene state
    record error-scene {
        error: client-error,
        can-retry: bool,
    }

    /// Client error types
    variant client-error {
        character-error(u32),
        connection-failed(string),
        patching-failed(string),
        login-timeout,
        patching-timeout,
    }

    /// ===== Events =====

    /// Character error from the server
    record character-error {
        error-code: u32,
        error-message: string,
    }

    /// Account information with character list (event payload)
    record account-data {
        account: string,
        characters: list<character-identity>,
        num-slots: u32,
    }

    /// Game events from the server
    variant game-event {
        /// Character list received from server
        character-list-received(account-data),
        /// Character error received from server
        character-error(character-error),
        /// Object created in game world
        create-object(world-object),
        /// Chat message received
        chat-message-received(chat-message),

        /// Full protocol event access (new replacement for SimpleGameEvent)
        protocol(protocol-event),
    }

    /// Chat message from the game
    record chat-message {
        channel: u8,
        message: string,
    }

    /// ===== Protocol Event Types (Full acprotocol access) =====

    // ----- S2C Message Records -----

    record login-create-player-msg {
        character-id: u32,
    }

    record login-character-set-msg {
        account: string,
        characters: list<character-identity>,
        num-slots: u32,
    }

    record item-create-object-msg {
        object-id: u32,
        name: string,
    }

    record hear-speech-msg {
        sender-name: string,
        message: string,
        message-type: u32,
    }

    record hear-ranged-speech-msg {
        sender-name: string,
        message: string,
        message-type: u32,
    }

    record ddd-interrogation-msg {
        language: string,
        region: string,
        product: string,
    }

    // ----- Game Event Records -----

    record hear-direct-speech-msg {
        message: string,
        sender-name: string,
        sender-id: u32,
        target-id: u32,
        message-type: u32,
    }

    record transient-string-msg {
        message: string,
    }

    // ----- Top-level S2C Messages -----

    /// Top-level server-to-client messages
    variant s2c-event {
        login-create-player(login-create-player-msg),
        login-character-set(login-character-set-msg),
        item-create-object(item-create-object-msg),
        character-error(character-error),
        hear-speech(hear-speech-msg),
        hear-ranged-speech(hear-ranged-speech-msg),
        ddd-interrogation(ddd-interrogation-msg),
        chargen-verification-response,
    }

    // ----- Nested Game Events -----

    /// Nested game events (from OrderedGameEvent wrapper)
    variant game-event-msg {
        hear-direct-speech(hear-direct-speech-msg),
        transient-string(transient-string-msg),
    }

    // ----- Unified Protocol Event -----

    /// Wrapper for ordered game events with metadata
    record ordered-game-event {
        object-id: u32,
        sequence: u32,
        event: game-event-msg,
    }

    /// Protocol event from server (unified wrapper)
    variant protocol-event {
        /// Top-level S2C message
        s2c(s2c-event),
        /// Nested game event with metadata
        game-event(ordered-game-event),
    }

    /// Client state change events
    variant state-event {
        connecting,
        connected,
        connecting-failed(string),
        patching,
        patched,
        patching-failed(string),
        character-select,
        entering-world,
        in-world,
        exiting-world,
        character-error,
    }

    /// System lifecycle events
    variant system-event {
        /// Authentication succeeded
        authentication-succeeded,
        /// Authentication failed
        authentication-failed(string),
        /// Connecting phase started
        connecting-started,
        /// Connecting phase completed
        connecting-done,
        /// Updating/patching phase started
        updating-started,
        /// Updating/patching phase completed
        updating-done,
        /// Login succeeded
        login-succeeded(login-info),
        /// Connection was lost
        disconnected,
        /// Attempting to reconnect
        reconnecting,
        /// Script reload requested
        reload-scripts,
        /// System shutdown requested
        shutdown,
    }

    /// Login information
    record login-info {
        character-id: u32,
        character-name: string,
    }

    /// Unified event type that scripts receive
    variant script-event {
        /// Game event from server
        game(game-event),
        /// Client state change
        state(state-event),
        /// System lifecycle event
        system(system-event),
    }

    /// ===== Action Methods =====

    /// Send a chat message to the server
    send-chat: func(message: string);

    /// Login as a specific character
    login-character: func(account-name: string, character-id: u32, character-name: string);

    /// Log a message from the script (will be displayed with script name)
    log: func(message: string);

    /// ===== Timer Methods =====

    /// Schedule a one-shot timer (returns timer ID)
    schedule-timer: func(delay-secs: u64, name: string) -> u64;

    /// Schedule a recurring timer (returns timer ID)
    schedule-recurring: func(interval-secs: u64, name: string) -> u64;

    /// Cancel a timer
    cancel-timer: func(timer-id: u64) -> bool;

    /// Check if a timer has fired (consumes the fired state)
    check-timer: func(timer-id: u64) -> bool;

    /// ===== State Access =====

    /// Get current client state
    get-client-state: func() -> client-state;

    /// Get current event time in milliseconds since epoch
    get-event-time-millis: func() -> u64;
}

/// Interface defining what WASM scripts must export to the host
interface guest {
    use host.{script-event};

    /// Initialize the script (MUST be called before other functions)
    init: func();

    /// Get the unique script ID
    get-id: func() -> string;

    /// Get the human-readable script name
    get-name: func() -> string;

    /// Get the script description
    get-description: func() -> string;

    /// Called when the script is first loaded
    on-load: func();

    /// Called when the script is being unloaded
    on-unload: func();

    /// Return list of event filter IDs this script subscribes to
    /// Values correspond to EventFilter enum discriminants (see host interface)
    subscribed-events: func() -> list<u32>;

    /// Handle a script event (game, state, or system)
    on-event: func(event: script-event);

    /// Called periodically at fixed rate (default 20Hz)
    /// delta-millis: milliseconds since last tick
    on-tick: func(delta-millis: u64);
}

/// The script world combining host and guest interfaces
world script {
    /// Import host functions
    import host;

    /// Export guest functions
    export guest;
}
