use anyhow::{Context, Result};
use std::any::Any;
use std::time::Duration;
use wasmtime::component::{Component, Linker, ResourceTable};
use wasmtime::{Engine, Store};
use wasmtime_wasi::{WasiCtx, WasiView};

use crate::Script as HostScript;
use crate::{EventFilter, context::ScriptContext};
use gromnie_events::{
    ClientEvent, ClientStateEvent, ClientSystemEvent, SimpleGameEvent as GameEvent,
};

// Generate bindings from WIT (use the canonical definition from gromnie-scripting-api)
wasmtime::component::bindgen!({
    path: "../gromnie-scripting-api/src/wit",
    world: "script",
    async: false,
});

/// State held in the WASM store
pub struct WasmScriptState {
    /// WASI context for filesystem/stdio access
    wasi: WasiCtx,
    /// Resource table for WASI
    table: ResourceTable,
    /// Pointer to the current ScriptContext (set during callbacks)
    pub(crate) host_context: Option<*mut ScriptContext>,
    /// Script ID (for logging)
    pub(crate) script_id: String,
}

// SAFETY: WasmScriptState is Send because:
// 1. WasiCtx and ResourceTable are both Send
// 2. The host_context pointer is only used on the owning thread
// 3. The pointer is set before each WASM call and cleared after
// 4. WASM scripts cannot store or use the pointer across calls
// 5. The ScriptContext it points to lives in ScriptRunner which owns the WasmScript
unsafe impl Send for WasmScriptState {}

impl WasiView for WasmScriptState {
    fn ctx(&mut self) -> &mut WasiCtx {
        &mut self.wasi
    }

    fn table(&mut self) -> &mut ResourceTable {
        &mut self.table
    }
}

/// Wrapper that adapts a WASM component to implement the Script trait
pub struct WasmScript {
    /// Store holds WASM instance + state
    store: Store<WasmScriptState>,
    /// WASM component instance (generated by bindgen)
    script: Script,

    /// Cached metadata (retrieved once at load time)
    id: String,
    name: String,
    description: String,
    subscribed_events: Vec<EventFilter>,
}

impl WasmScript {
    /// Load a WASM component from a file
    pub fn from_file(engine: &Engine, path: impl AsRef<std::path::Path>) -> Result<Self> {
        let path = path.as_ref();

        // Load component from file
        let component = Component::from_file(engine, path)
            .with_context(|| format!("Failed to load WASM component: {}", path.display()))?;

        // Create WASI context
        let wasi = super::engine::create_wasi_context()?;
        let table = ResourceTable::new();

        let state = WasmScriptState {
            wasi,
            table,
            host_context: None,
            script_id: String::new(), // Will be updated after instantiation
        };

        let mut store = Store::new(engine, state);

        // Create linker and add WASI + host imports
        let mut linker = Linker::new(engine);

        // Add WASI support
        wasmtime_wasi::add_to_linker_sync(&mut linker).context("Failed to add WASI to linker")?;

        // Add our host imports (will be implemented separately)
        crate::wasm::bindings::add_host_imports(&mut linker)?;

        // Instantiate the component
        let script = Script::instantiate(&mut store, &component, &linker)
            .context("Failed to instantiate WASM script")?;

        // Call metadata functions to cache values
        let guest = script.gromnie_scripting_guest();

        // Initialize the script first
        guest
            .call_init(&mut store)
            .context("Failed to initialize script")?;

        let id = guest
            .call_get_id(&mut store)
            .context("Failed to get script ID")?;

        // Update the script_id in the store state now that we have it
        store.data_mut().script_id = id.clone();

        let name = guest
            .call_get_name(&mut store)
            .context("Failed to get script name")?;

        let description = guest
            .call_get_description(&mut store)
            .context("Failed to get script description")?;

        let subscribed_event_ids = guest
            .call_subscribed_events(&mut store)
            .context("Failed to get subscribed events")?;

        // Convert u32 discriminants to EventFilter enum
        let subscribed_events = subscribed_event_ids
            .into_iter()
            .filter_map(EventFilter::from_discriminant)
            .collect();

        Ok(Self {
            store,
            script,
            id,
            name,
            description,
            subscribed_events,
        })
    }

    /// Set the host context pointer for the current operation
    fn set_context(&mut self, ctx: &mut ScriptContext) {
        self.store.data_mut().host_context = Some(ctx as *mut ScriptContext);
    }

    /// Clear the host context pointer
    fn clear_context(&mut self) {
        self.store.data_mut().host_context = None;
    }

    /// Execute a WASM function call outside of the tokio runtime context
    ///
    /// This is necessary because wasmtime-wasi's sync filesystem operations
    /// internally try to use tokio::runtime::Handle::block_on, which panics
    /// if called from within an existing tokio runtime.
    fn call_wasm<F, R>(&mut self, f: F) -> R
    where
        F: FnOnce(&mut Self) -> R + Send,
        R: Send,
    {
        // Check if we're in a tokio runtime context
        if tokio::runtime::Handle::try_current().is_ok() {
            // We're in a tokio runtime, use block_in_place to move off the runtime thread
            tokio::task::block_in_place(|| f(self))
        } else {
            // Not in a tokio runtime, call directly
            f(self)
        }
    }

    /// Execute a WASM lifecycle method with proper context management
    fn with_context<F>(&mut self, ctx: &mut ScriptContext, f: F)
    where
        F: FnOnce(&mut Self) + Send,
    {
        self.set_context(ctx);
        self.call_wasm(|this| f(this));
        self.clear_context();
    }
}

impl HostScript for WasmScript {
    fn id(&self) -> &'static str {
        // SAFETY: This is safe because:
        // 1. The string data is stored in self.id (a String field)
        // 2. WasmScript implements 'static (scripts are loaded once and kept alive)
        // 3. The string content never changes after initialization
        // 4. The WasmScript struct is not moved after creation
        unsafe { std::mem::transmute(self.id.as_str()) }
    }

    fn name(&self) -> &'static str {
        // SAFETY: Same reasoning as id() - string is stored in struct and never changes
        unsafe { std::mem::transmute(self.name.as_str()) }
    }

    fn description(&self) -> &'static str {
        // SAFETY: Same reasoning as id() - string is stored in struct and never changes
        unsafe { std::mem::transmute(self.description.as_str()) }
    }

    fn on_load(&mut self, ctx: &mut ScriptContext) {
        self.with_context(ctx, |this| {
            let guest = this.script.gromnie_scripting_guest();
            if let Err(e) = guest.call_on_load(&mut this.store) {
                tracing::error!(target: "scripting", "Script {} on_load failed: {:#}", this.id, e);
            }
        });
    }

    fn on_unload(&mut self, ctx: &mut ScriptContext) {
        self.with_context(ctx, |this| {
            let guest = this.script.gromnie_scripting_guest();
            if let Err(e) = guest.call_on_unload(&mut this.store) {
                tracing::error!(target: "scripting", "Script {} on_unload failed: {:#}", this.id, e);
            }
        });
    }

    fn subscribed_events(&self) -> &[EventFilter] {
        &self.subscribed_events
    }

    fn on_event(&mut self, event: &ClientEvent, ctx: &mut ScriptContext) {
        // Convert Rust ClientEvent to WIT ScriptEvent
        let wasm_event = client_event_to_wasm(event);

        self.with_context(ctx, move |this| {
            let guest = this.script.gromnie_scripting_guest();
            if let Err(e) = guest.call_on_event(&mut this.store, &wasm_event) {
                tracing::error!(
                    target: "scripting",
                    "Script {} on_event failed: {:#}",
                    this.id,
                    e
                );
            }
        });
    }

    fn on_tick(&mut self, ctx: &mut ScriptContext, delta: Duration) {
        let delta_millis = delta.as_millis() as u64;

        self.with_context(ctx, move |this| {
            let guest = this.script.gromnie_scripting_guest();
            if let Err(e) = guest.call_on_tick(&mut this.store, delta_millis) {
                tracing::error!(
                    target: "scripting",
                    "Script {} on_tick failed: {:#}",
                    this.id,
                    e
                );
            }
        });
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
}

/// Convert Rust ClientEvent to WIT ScriptEvent
fn client_event_to_wasm(event: &ClientEvent) -> gromnie::scripting::host::ScriptEvent {
    use gromnie::scripting::host::ScriptEvent as WitScriptEvent;

    match event {
        ClientEvent::Game(game_event) => WitScriptEvent::Game(game_event_to_wasm(game_event)),
        ClientEvent::State(state_event) => WitScriptEvent::State(state_event_to_wasm(state_event)),
        ClientEvent::System(system_event) => {
            WitScriptEvent::System(system_event_to_wasm(system_event))
        }
    }
}

/// Convert Rust GameEvent to WIT GameEvent
fn game_event_to_wasm(event: &GameEvent) -> gromnie::scripting::host::GameEvent {
    use gromnie::scripting::host::{
        Account, CharacterListEntry, ChatMessage, GameEvent as WitGameEvent, WorldObject,
    };

    match event {
        GameEvent::CharacterListReceived {
            account,
            characters,
            num_slots,
        } => WitGameEvent::CharacterListReceived(Account {
            name: account.clone(),
            num_slots: *num_slots as u8,
            character_list: characters
                .iter()
                .map(|c| CharacterListEntry {
                    id: c.id,
                    name: c.name.clone(),
                    delete_pending: c.delete_pending,
                })
                .collect(),
        }),

        GameEvent::CreateObject {
            object_id,
            object_name,
        } => WitGameEvent::CreateObject(WorldObject {
            id: *object_id,
            name: object_name.clone(),
        }),

        GameEvent::ChatMessageReceived {
            message,
            message_type,
        } => WitGameEvent::ChatMessageReceived(ChatMessage {
            channel: *message_type as u8,
            message: message.clone(),
        }),

        // Handle events that still exist in GameEvent but aren't in WIT
        // These will be filtered out by the event filter in the future
        _ => {
            tracing::warn!(
                target: "scripting",
                "Received event {:?} that is not supported in WIT interface - skipping",
                event
            );
            // Return a dummy event - this should never reach WASM scripts
            // since they won't be subscribed to events not in the WIT
            WitGameEvent::ChatMessageReceived(ChatMessage {
                channel: 0,
                message: String::new(),
            })
        }
    }
}

/// Convert Rust StateEvent to WIT StateEvent
fn state_event_to_wasm(event: &ClientStateEvent) -> gromnie::scripting::host::StateEvent {
    use gromnie::scripting::host::StateEvent as WitStateEvent;

    match event {
        ClientStateEvent::Connecting => WitStateEvent::Connecting,
        ClientStateEvent::Connected => WitStateEvent::Connected,
        ClientStateEvent::ConnectingFailed { reason } => {
            WitStateEvent::ConnectingFailed(reason.clone())
        }
        ClientStateEvent::Patching => WitStateEvent::Patching,
        ClientStateEvent::Patched => WitStateEvent::Patched,
        ClientStateEvent::PatchingFailed { reason } => {
            WitStateEvent::PatchingFailed(reason.clone())
        }
        ClientStateEvent::CharacterSelect => WitStateEvent::CharacterSelect,
        ClientStateEvent::EnteringWorld => WitStateEvent::EnteringWorld,
        ClientStateEvent::InWorld => WitStateEvent::InWorld,
        ClientStateEvent::ExitingWorld => WitStateEvent::ExitingWorld,
        ClientStateEvent::CharacterError => WitStateEvent::CharacterError,
    }
}

/// Convert Rust SystemEvent to WIT SystemEvent
fn system_event_to_wasm(event: &ClientSystemEvent) -> gromnie::scripting::host::SystemEvent {
    use gromnie::scripting::host::{LoginInfo, SystemEvent as WitSystemEvent};

    match event {
        ClientSystemEvent::AuthenticationSucceeded => WitSystemEvent::AuthenticationSucceeded,
        ClientSystemEvent::AuthenticationFailed { reason } => {
            WitSystemEvent::AuthenticationFailed(reason.clone())
        }
        ClientSystemEvent::ConnectingStarted => WitSystemEvent::ConnectingStarted,
        ClientSystemEvent::ConnectingDone => WitSystemEvent::ConnectingDone,
        ClientSystemEvent::UpdatingStarted => WitSystemEvent::UpdatingStarted,
        ClientSystemEvent::UpdatingDone => WitSystemEvent::UpdatingDone,
        ClientSystemEvent::LoginSucceeded {
            character_id,
            character_name,
        } => WitSystemEvent::LoginSucceeded(LoginInfo {
            character_id: *character_id,
            character_name: character_name.clone(),
        }),
        ClientSystemEvent::Disconnected { .. } => WitSystemEvent::Disconnected,
        ClientSystemEvent::Reconnecting { .. } => WitSystemEvent::Reconnecting,
    }
}
